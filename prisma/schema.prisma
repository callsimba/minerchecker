generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model Algorithm {
  id             String   @id @default(cuid())
  key            String   @unique
  name           String
  unit           String
  efficiencyUnit String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  coins    Coin[]
  machines Machine[]
}

model Coin {
  id           String   @id @default(cuid())
  key          String   @unique
  symbol       String
  name         String
  algorithmId  String
  blockTimeSec Int?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  algorithm        Algorithm               @relation(fields: [algorithmId], references: [id])
  miners           MachineCoin[]
  bestForSnapshots ProfitabilitySnapshot[] @relation("BestCoinSnapshots")

  @@index([algorithmId])
}

model Machine {
  id             String        @id @default(cuid())
  slug           String        @unique
  name           String
  manufacturer   String?
  algorithmId    String
  hashrate       String
  hashrateUnit   String
  powerW         Int
  efficiency     String?
  efficiencyUnit String?
  releaseDate    DateTime?
  status         MachineStatus @default(AVAILABLE)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  imageUrl       String?

  algorithm              Algorithm               @relation(fields: [algorithmId], references: [id])
  canMineCoins           MachineCoin[]
  profitabilitySnapshots ProfitabilitySnapshot[]
  vendorOfferings        VendorOffering[]
  watchlistedBy          WatchlistItem[]

  @@index([algorithmId])
  @@index([status])
}

model MachineCoin {
  id        String   @id @default(cuid())
  machineId String
  coinId    String
  createdAt DateTime @default(now())

  coin    Coin    @relation(fields: [coinId], references: [id], onDelete: Cascade)
  machine Machine @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@unique([machineId, coinId])
  @@index([coinId])
  @@index([machineId])
}

model Vendor {
  id         String     @id @default(cuid())
  slug       String     @unique
  name       String
  websiteUrl String?
  trustLevel TrustLevel @default(UNKNOWN)
  isVerified Boolean    @default(false)
  notes      String?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  country    String?
  logoUrl    String?

  featureFlags FeatureFlag[]
  offerings    VendorOffering[]

  @@index([isVerified])
  @@index([trustLevel])
  @@index([country])
}

model VendorOffering {
  id        String @id @default(cuid())
  vendorId  String
  machineId String
  currency  String
  regionKey String @default("GLOBAL")

  // ✅ Enterprise: Decimal money types
  price        Decimal  @db.Decimal(18, 2)
  shippingCost Decimal? @db.Decimal(18, 2)

  productUrl     String?
  inStock        Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  psuIncluded    Boolean  @default(false)
  warrantyMonths Int?

  machine Machine @relation(fields: [machineId], references: [id], onDelete: Cascade)
  vendor  Vendor  @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  @@unique([vendorId, machineId, currency, regionKey], name: "vendorId_machineId_currency_regionKey")
  // ✅ Marketplace query performance
  @@index([machineId])
  @@index([vendorId])
  @@index([currency])
  @@index([regionKey])
  @@index([inStock])
  @@index([machineId, regionKey, inStock])
}

model ProfitabilitySnapshot {
  id        String @id @default(cuid())
  machineId String

  // ✅ computedAt is controlled by compute job (bucketed timestamp)
  computedAt DateTime

  // ✅ Enterprise: Decimals
  electricityUsdPerKwh Decimal  @db.Decimal(10, 5)
  revenueUsdPerDay     Decimal  @db.Decimal(18, 6)
  electricityUsdPerDay Decimal  @db.Decimal(18, 6)
  profitUsdPerDay      Decimal  @db.Decimal(18, 6)
  lowestPriceUsd       Decimal? @db.Decimal(18, 2)

  bestCoinId String?
  roiDays    Int?

  breakdown          Json?
  bestCoinConfidence Int?
  bestCoinReason     String?

  createdAt DateTime @default(now())

  bestCoin Coin?   @relation("BestCoinSnapshots", fields: [bestCoinId], references: [id])
  machine  Machine @relation(fields: [machineId], references: [id], onDelete: Cascade)

  // ✅ prevents DB spam + enables skipDuplicates
  @@unique([machineId, computedAt])
  @@index([machineId, computedAt])
  @@index([computedAt])
  @@index([bestCoinId])
}

model FxRateSnapshot {
  id           String   @id @default(cuid())
  baseCurrency String   @default("USD")
  rates        Json
  fetchedAt    DateTime @default(now())

  @@index([fetchedAt])
}

model Settings {
  id        String   @id @default(cuid())
  key       String   @unique
  value     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FeatureFlag {
  id        String           @id @default(cuid())
  scope     FeatureFlagScope
  key       FeatureFlagKey
  enabled   Boolean          @default(false)
  vendorId  String
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  vendor Vendor @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  @@unique([scope, key, vendorId], name: "scope_key_vendorId")
  @@index([key])
  @@index([vendorId])
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts        Account[]
  auditLogs       AuditLog[]
  sessions        Session[]
  roles           UserRole[]
  watchlist       WatchlistItem[]
  supportTickets  SupportTicket[] @relation("UserSupportTickets")
  assignedTickets SupportTicket[] @relation("UserAssignedTickets")
  supportReplies  SupportReply[]  @relation("UserSupportReplies")
}

model Account {
  id                String   @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Role {
  id          String   @id @default(cuid())
  key         String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users UserRole[]
}

model UserRole {
  id        String   @id @default(cuid())
  userId    String
  roleId    String
  createdAt DateTime @default(now())

  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@index([roleId])
  @@index([userId])
}

model WatchlistItem {
  id        String   @id @default(cuid())
  userId    String
  machineId String
  createdAt DateTime @default(now())

  machine Machine @relation(fields: [machineId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, machineId])
  @@index([machineId])
  @@index([userId])
}

model AuditLog {
  id          String      @id @default(cuid())
  actorUserId String?
  action      AuditAction
  entity      String
  entityId    String
  before      Json?
  after       Json?
  ip          String?
  userAgent   String?
  createdAt   DateTime    @default(now())

  actor User? @relation(fields: [actorUserId], references: [id])

  @@index([entity, entityId])
  @@index([createdAt])
  @@index([actorUserId])
}

//
// ✅ NEW: Mining events table
//
model MiningEvent {
  id     String            @id @default(cuid())
  slug   String            @unique
  title  String
  type   MiningEventType   @default(CONFERENCE)
  status MiningEventStatus @default(CONFIRMED)

  // When
  startAt  DateTime
  endAt    DateTime?
  timezone String? // e.g. "America/Los_Angeles" (optional)

  // Where
  isVirtual Boolean @default(false)
  venue     String?
  city      String?
  country   String?
  regionKey String  @default("GLOBAL") // aligns with your VendorOffering regionKey

  // Links + media
  websiteUrl String?
  ticketUrl  String?
  imageUrl   String?

  // Extra info
  organizer   String?
  description String?
  tags        String[] // Postgres text[]

  // Curation / provenance
  source String? // e.g. "official site", "press release"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([startAt])
  @@index([type])
  @@index([status])
  @@index([country])
  @@index([regionKey])
}

model SupportTicket {
  id       String                @id @default(cuid())
  status   SupportTicketStatus   @default(OPEN)
  priority SupportTicketPriority @default(NORMAL)

  // User-submitted fields
  name    String?
  email   String
  topic   String
  subject String?
  message String

  // Optional: if the sender is a logged-in user
  userId String?
  user   User?   @relation("UserSupportTickets", fields: [userId], references: [id], onDelete: SetNull)

  // Admin workflow
  adminNotes   String?
  assignedToId String?
  assignedTo   User?   @relation("UserAssignedTickets", fields: [assignedToId], references: [id], onDelete: SetNull)

  // Thread
  replies SupportReply[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([priority])
  @@index([createdAt])
  @@index([userId])
  @@index([assignedToId])
}

model SupportReply {
  id String @id @default(cuid())

  ticketId String
  ticket   SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  // Who replied (admin/editor) - optional to allow system replies
  actorUserId String?
  actorUser   User?   @relation("UserSupportReplies", fields: [actorUserId], references: [id], onDelete: SetNull)

  // Message
  body String

  // Optional: whether user should be notified later if you add email sending
  isInternal Boolean @default(false)

  createdAt DateTime @default(now())

  @@index([ticketId])
  @@index([actorUserId])
}

enum MachineStatus {
  AVAILABLE
  COMING_SOON
  DISCONTINUED
}

enum TrustLevel {
  UNKNOWN
  LOW
  MEDIUM
  HIGH
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
}

enum FeatureFlagScope {
  GLOBAL
  VENDOR
}

enum FeatureFlagKey {
  VENDOR_AUTO_PRICE_FETCH
}

//
enum MiningEventType {
  CONFERENCE
  HARDWARE_LAUNCH
  NETWORK_EVENT
  WEBINAR
  MEETUP
  OTHER
}

enum MiningEventStatus {
  CONFIRMED
  TENTATIVE
  CANCELLED
}

enum SupportTicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_ON_USER
  RESOLVED
  CLOSED
}

enum SupportTicketPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}
